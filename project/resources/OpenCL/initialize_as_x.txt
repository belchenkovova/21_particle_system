kernel void				initialize_as_null(
						constant vector3 *global_color,
						global char *is_alive,
						global vector3 *position,
                        global vector3 *velocity,
                        global vector3 *acceleration,
                        global vector4 *color,
						global int *born_by_emitter)
{
	particle_reset_target(
		global_color,
		is_alive,
		position,
		velocity,
		acceleration,
		color,
		born_by_emitter,
		get_global_id(0));
}

#define CUBE_SIDE		1000
#define CUBE_POSITION	((vector3){0, 0, 0})

#define AXIS_X			0
#define AXIS_Y			1
#define AXIS_Z			2

#define SIDE_LEFT		0
#define SIDE_RIGHT		1

kernel void				initialize_as_cube(
						constant vector3 *global_color,
						global char *is_alive,
						global vector3 *position,
						global vector3 *velocity,
						global vector3 *acceleration,
						global vector4 *color,
						global xorshift_state *state,
						global int *born_by_emitter)
{
	const int			global_id = get_global_id(0);

	particle_reset_target(
		global_color,
		is_alive,
		position,
		velocity,
		acceleration,
		color,
		born_by_emitter,
		global_id);
    is_alive[global_id] = 1;

	const int			axis = xorshift_next_in_range(state + global_id, AXIS_X, AXIS_Z);
	const int			side = xorshift_next_in_range(state + global_id, SIDE_LEFT, SIDE_RIGHT);

	const float			random_a = xorshift_next_float(state + global_id) * CUBE_SIDE;
	const float			random_b = xorshift_next_float(state + global_id) * CUBE_SIDE;

	switch (axis)
	{
		case AXIS_X :
			position[global_id].x = side * CUBE_SIDE;
			position[global_id].y = random_a;
			position[global_id].z = random_b;
			break ;

		case AXIS_Y :
            position[global_id].x = random_a;
            position[global_id].y = side * CUBE_SIDE;
            position[global_id].z = random_b;
            break ;

		case AXIS_Z :
			position[global_id].x = random_a;
			position[global_id].y = random_b;
			position[global_id].z = side * CUBE_SIDE;
			break ;

		default :
			break ;
	}

	position[global_id].x -= CUBE_SIDE / 2 + CUBE_POSITION.x;
	position[global_id].y -= CUBE_SIDE / 2 + CUBE_POSITION.y;
	position[global_id].z -= CUBE_SIDE / 2 + CUBE_POSITION.z;
}

#define SPHERE_RADIUS	500
#define SPHERE_POSITION	((vector3){0, 0, 0})
#define PI_ON_2			6.28318530718

kernel void				initialize_as_sphere(
						constant vector3 *global_color,
						global char *is_alive,
						global vector3 *position,
						global vector3 *velocity,
						global vector3 *acceleration,
						global vector4 *color,
						global xorshift_state *state,
						global int *born_by_emitter)
{
	const int			global_id = get_global_id(0);

	particle_reset_target(
		global_color,
		is_alive,
		position,
		velocity,
		acceleration,
		color,
		born_by_emitter,
		global_id);
	is_alive[global_id] = 1;

	const float			theta = xorshift_next_float(state + global_id) * PI_ON_2;
	const float			v = xorshift_next_float(state + global_id);
	const float			phi = acos((2 * v) - 1);

	position[global_id].x = SPHERE_RADIUS * sin(phi) * cos(theta);
	position[global_id].y = SPHERE_RADIUS * sin(phi) * sin(theta);
	position[global_id].z = SPHERE_RADIUS * cos(phi);

	position[global_id].x += SPHERE_POSITION.x;
	position[global_id].y += SPHERE_POSITION.y;
	position[global_id].z += SPHERE_POSITION.z;
}