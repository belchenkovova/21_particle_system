Source
typedef struct
{
	float			x;
	float			y;
	float			z;
}					vector3;

static vector3		vector3_empty()
{
	return ((vector3){0, 0, 0});
}

static vector3		vector3_add(vector3 a, vector3 b)
{
	return ((vector3){a.x + b.x, a.y + b.y, a.z + b.z});
}

static vector3		vector3_subtract(vector3 a, vector3 b)
{
	return ((vector3){a.x - b.x, a.y - b.y, a.z - b.z});
}

static vector3		vector3_multiply(vector3 a, float value)
{
	return ((vector3){a.x * value, a.y * value, a.z * value});
}

static vector3		vector3_divide(vector3 v, float value)
{
	return (vector3_multiply(v, 1.f / value));
}

static float		vector3_length_squared(vector3 v)
{
	return (v.x * v.x + v.y * v.y + v.z * v.z);
}

static float		vector3_length(vector3 v)
{
	return (sqrt(vector3_length_squared(v)));
}

static vector3		vector3_normalize(vector3 v)
{
	return (vector3_divide(v, vector3_length(v)));
}

static void			vector3_print(vector3 v)
{
	printf("{%f, %f, %f}", v.x, v.y, v.z);
}

typedef struct
{
	float			x;
	float			y;
	float			z;
	float			w;
}					vector4;

#define MIN(a, b)			(a < b ? a : b)
#define MAX(a, b)			(a > b ? a : b)
#define CLAMP(x, min, max)	(x < min) ? min : (max < x) ? max : x

#define OBJECT_SIZE			((vector3){20, 20, 20})


typedef enum
{
	object_type_empty,
	object_type_attractor,
	object_type_repeller,
	object_type_emitter,
	object_type_consumer
}					object_type;

static void				particle_reset_target(
						constant vector3 *global_color,
						global char *is_alive,
						global vector3 *position,
						global vector3 *velocity,
						global vector3 *acceleration,
						global vector4 *color,
						global int *born_by_emitter,
						int id)
{
	is_alive[id] = 1;
	born_by_emitter[id] = -1;
	position[id] = vector3_empty();
	velocity[id] = vector3_empty();
	acceleration[id] = vector3_empty();
	color[id] = (vector4){global_color->x, global_color->y, global_color->z, 1};
}

kernel void				particle_reset(
						constant vector3 *global_color,
						global char *is_alive,
						global vector3 *position,
						global vector3 *velocity,
						global vector3 *acceleration,
						global vector4 *color,
						global int *born_by_emitter)
{
	particle_reset_target(
		global_color,
		is_alive,
		position,
		velocity,
		acceleration,
		color,
		born_by_emitter,
		get_global_id(0));
}

static float			distribute_float(float start, float finish, float ratio)
{
	return (start + (finish - start) * ratio);
}

kernel void				particle_update(
						constant vector3 *global_color,
						global vector3 *position,
						global vector3 *velocity,
						global vector3 *acceleration,
						global vector4 *color)
{
	const int			global_id = get_global_id(0);

	const vector3		change = vector3_add(velocity[global_id], acceleration[global_id]);

	position[global_id] = vector3_add(position[global_id], change);
	velocity[global_id] = vector3_add(vector3_multiply(velocity[global_id], 1), acceleration[global_id]);
	acceleration[global_id] = vector3_multiply(acceleration[global_id], 0.f);

	const vector3		finish_color = {1, 1, 1};

	const float			length = vector3_length(velocity[global_id]);
	const float			ratio = CLAMP(length / 10, 0, 1);

	color[global_id].x = distribute_float(global_color->x, finish_color.x, ratio);
	color[global_id].y = distribute_float(global_color->y, finish_color.y, ratio);
	color[global_id].z = distribute_float(global_color->z, finish_color.z, ratio);
	color[global_id].w = 1;
}

kernel void			consumer_execute(
					global int *number_of_objects,
					global object_type *object_type,
                    global vector3 *object_position,
                    global char *is_alive,
                    global vector3 *position,
					global vector3 *velocity,
					global vector3 *acceleration,
					global vector4 *color,
					global int *born_by_emitter)
{
	const int		global_id = get_global_id(0);

	const vector3	half_object_size = vector3_divide(OBJECT_SIZE, 2);
	vector3			min;
	vector3			max;

	float			how_close;
	float			velocity_multiplier;

	for (int object_i = 0; object_i < *number_of_objects; object_i++)
	{
		if (object_type[object_i] != object_type_consumer)
			continue ;

		if (is_alive[global_id] == 0)
        	continue ;

//					///////////////////////////////////////////////////////////
//					Gravity field
//					///////////////////////////////////////////////////////////

    how_close = vector3_length(vector3_subtract(object_position[object_i], position[global_id]));
    how_close = 1 - MIN(how_close / 200, 1);

    velocity_multiplier = 1 - 0.08 * how_close;

    velocity[global_id] = vector3_multiply(velocity[global_id], velocity_multiplier);

//					///////////////////////////////////////////////////////////
//					Consuming
//					///////////////////////////////////////////////////////////

		min = vector3_subtract(object_position[object_i], half_object_size);
        max = vector3_add(object_position[object_i], half_object_size);

		if (position[global_id].x < min.x || position[global_id].x > max.x)
			continue ;
		if (position[global_id].y < min.y || position[global_id].y > max.y)
			continue ;
		if (position[global_id].z < min.z || position[global_id].z > max.z)
			continue ;

		is_alive[global_id] = 0;
		particle_reset_target(
			position,
			is_alive,
			velocity,
			acceleration,
			color,
			born_by_emitter,
			global_id);
	}
}



